== Shamir’s Secret Sharing Scheme [SSSS]

Shamir’s Secret Sharing footnote:[Adi Shamir. How to Share a Secret. Communications of the ACM, Volume 22, November 1979.] is an algorithm used to divide a given master secret `MS` into `n` parts, such that `m` parts are required in order to compute the original master secret. If only `m-1` parts are available, no information about the master secret is revealed. If the `m-of-n` threshold scheme is  `n = 2m-1` then we can still recover `MS` even if `n/2 = m-1` of the `n` pieces are destroyed. However, an adversary cannot reconstruct `MS` even when he has compromised `n/2 = m-1` parts.

SSSS is based on polynomial interpolation: given `m` points in the 2-dimensional plane `(x_1, y_1) … (x_m, y_m)` there is only one function `q(x)` of degree `m-1` such that `q(x_i) = y_i` for all `i`. In order to protect against the attacker acquiring information about `MS` with every additional `D_i`, we use finite field arithmetic with a field of size `p ∊ P: p > MS, p > n`. Prime number `p` must be close enough to the desired security level, because a too large `p` leads to long cypher text, but a too small `p` leads to compromised security.

=== Preparation
 
After specifying `MS`, `m` and `n`, we generate `m-1` random numbers `a_1, … a_[m-1]` and build a polynomial with the secret as `a_0`.  The polynomial is thus `q(x) = a_0 + a_1*x + a_2*x^2 + … + a_[m-1]*x^[m-1]`.

Then we construct `n` points `D_[x-1] = (x, q(x) mod p)` from the polynomial and each party gets a different point [both `x` and `q(x)`], the `MS` is `q(0)`. Each sub-secret is a point `n` on the constructed polynomial curve.

=== Reconstruction

To reconstruct `MS`, any `m` of `n` will be enough to compute the entire polynomial `q(x)` with the Lagrange interpolation formula footnote:[Hazewinkel, Michiel. Lagrange interpolation formula. Encyclopedia of Mathematics, Springer Science+Business Media B.V. 1994].

=== Simulated shared ownership

SSSS can distribute the knowledge of a secret across several different sub-secret, where each of the holders has full knowledge of his individual part. However, the dealer first generates a master secret, which he has full knowledge off. Thus the dealer has full access and property rights in the funds locked up by the master secret. The sub-secret holders thus have a simulated shared ownership, however, they rely on the good will of the dealer to not spend the funds on his own accord. The use case for SSSS is thus more to backup a private key among semi-trusted peers, but where the dealer and owner of the bitcoin has always full control himself. This is a vitally important differentiation compared to some secure key and signature aggregation footnote:[Refer to chapter on Schnorr MuSig], which generates non-simulated shared ownership.

=== Verifiable Secret Sharing Scheme

Verifiable Secret Sharing Scheme [VSS] is used to prevent the dealer from cheating, every peer can verify his own share and will detect when the dealer has distributed inconsistent shares. footnote:[Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. Lecture Notes in Computer Science (Crypto '90), 473:331-238, 1991.]

The dealer specifies `MS ∈ Z` and a random numer `MS' ∈ Z` and commits to them by publicly releasing `C_0 = MS*G + MS'*H`. Then he chooses a random polynomials `f(u) = MS + f_1 u + ... + f_t+1 u^t-1` and `f'(u) = MS' + f'_1 u + ... + f'_t+1 u^t-1` to compute `(s_i, s'_i) = (f(i), f'(i)) for i ∈ {1, ..., n}`. The tuple `(s_i, s'_i)` is send secretly to player `P_i` for `1 <  i < n`. Then the master dealer publicly commits the values `C_j = f_j*G + f'_j*H for 1 =< j =< t-1`.

Then each player `P_i` verifies that `s_i*G + s'_i*H = for t-1 <= j = 0 <= sum of i^j*C_j`, if this is false, the dealer accused and he cand efend himself by revealing the value `(f(i), f'(i)`. The dealer is rejected if there are more than `m` complaints, or if his defense does not validate the equation.












































